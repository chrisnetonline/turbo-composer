use std::collections::BTreeMap;
use std::fmt::Write;

use super::{FileAutoload, NamespaceMapping};

pub(crate) fn php_var_export(s: &str) -> String {
    let mut out = String::with_capacity(s.len() + 4);
    out.push('\'');
    for ch in s.chars() {
        match ch {
            '\'' => out.push_str("\\'"),
            '\\' => out.push_str("\\\\"),
            _ => out.push(ch),
        }
    }
    out.push('\'');
    out
}

pub(crate) fn file_path_code(abs_path: &str, vendor_dir: &str, project_dir: &str) -> String {
    if let Some(rel) = abs_path.strip_prefix(vendor_dir) {
        format!("$vendorDir . {}", php_var_export(rel))
    } else if let Some(rel) = abs_path.strip_prefix(project_dir) {
        format!("$baseDir . {}", php_var_export(rel))
    } else {
        php_var_export(abs_path)
    }
}

fn static_path_code(
    abs_path: &str,
    vendor_dir: &str,
    project_dir: &str,
    vendor_rel: &str,
    base_rel: &str,
) -> String {
    if let Some(rel) = abs_path.strip_prefix(vendor_dir) {
        format!(
            "__DIR__ . {} . {}",
            php_var_export(vendor_rel),
            php_var_export(rel)
        )
    } else if let Some(rel) = abs_path.strip_prefix(project_dir) {
        format!(
            "__DIR__ . {} . {}",
            php_var_export(base_rel),
            php_var_export(rel)
        )
    } else {
        php_var_export(abs_path)
    }
}

pub(crate) fn relative_dir_path(from: &str, to: &str) -> String {
    let from_parts: Vec<&str> = from.split('/').filter(|s| !s.is_empty()).collect();
    let to_parts: Vec<&str> = to.split('/').filter(|s| !s.is_empty()).collect();

    let common = from_parts
        .iter()
        .zip(to_parts.iter())
        .take_while(|(a, b)| a == b)
        .count();

    let ups = from_parts.len() - common;
    let mut result = String::new();
    for _ in 0..ups {
        result.push_str("/..");
    }
    for part in &to_parts[common..] {
        result.push('/');
        result.push_str(part);
    }
    if result.is_empty() {
        "/".to_string()
    } else {
        result
    }
}

fn php_file_header(comment: &str) -> String {
    format!(
        "<?php\n\n// {} @generated by Composer\n\n$vendorDir = dirname(__DIR__);\n$baseDir = dirname($vendorDir);\n\nreturn array(\n",
        comment
    )
}

pub(crate) fn generate_psr4_file(
    mappings: &[NamespaceMapping],
    vendor_dir: &str,
    project_dir: &str,
) -> String {
    let mut out = php_file_header("autoload_psr4.php");

    let mut ns_paths: BTreeMap<&str, Vec<&str>> = BTreeMap::new();
    for m in mappings {
        ns_paths.entry(&m.namespace).or_default().push(&m.path);
    }

    for (ns, paths) in &ns_paths {
        let exported_paths: Vec<String> = paths
            .iter()
            .map(|p| file_path_code(p, vendor_dir, project_dir))
            .collect();
        let _ = writeln!(
            out,
            "    {} => array({}),",
            php_var_export(ns),
            exported_paths.join(", ")
        );
    }

    out.push_str(");\n");
    out
}

pub(crate) fn generate_namespaces_file(
    mappings: &[NamespaceMapping],
    vendor_dir: &str,
    project_dir: &str,
) -> String {
    let mut out = php_file_header("autoload_namespaces.php");

    let mut ns_paths: BTreeMap<&str, Vec<&str>> = BTreeMap::new();
    for m in mappings {
        ns_paths.entry(&m.namespace).or_default().push(&m.path);
    }

    for (ns, paths) in &ns_paths {
        let exported_paths: Vec<String> = paths
            .iter()
            .map(|p| file_path_code(p, vendor_dir, project_dir))
            .collect();
        let _ = writeln!(
            out,
            "    {} => array({}),",
            php_var_export(ns),
            exported_paths.join(", ")
        );
    }

    out.push_str(");\n");
    out
}

pub(crate) fn generate_files_file(
    file_autoloads: &[FileAutoload],
    vendor_dir: &str,
    project_dir: &str,
) -> String {
    if file_autoloads.is_empty() {
        return String::new();
    }

    let mut out = php_file_header("autoload_files.php");

    for f in file_autoloads {
        let path_code = file_path_code(&f.path, vendor_dir, project_dir);
        let _ = writeln!(
            out,
            "    {} => {},",
            php_var_export(&f.identifier),
            path_code
        );
    }

    out.push_str(");\n");
    out
}

pub(crate) fn generate_classmap_file(
    classmap: &BTreeMap<String, String>,
    vendor_dir: &str,
    project_dir: &str,
) -> String {
    let capacity = classmap.len() * 80 + 256;
    let mut out = String::with_capacity(capacity);
    out.push_str(&php_file_header("autoload_classmap.php"));

    for (class, abs_path) in classmap {
        let path_code = file_path_code(abs_path, vendor_dir, project_dir);
        let _ = writeln!(out, "    {} => {},", php_var_export(class), path_code);
    }

    out.push_str(");\n");
    out
}

#[allow(clippy::too_many_arguments)]
pub(crate) fn generate_static_file(
    suffix: &str,
    psr4: &[NamespaceMapping],
    psr0: &[NamespaceMapping],
    classmap: &BTreeMap<String, String>,
    file_autoloads: &[FileAutoload],
    vendor_dir: &str,
    project_dir: &str,
    target_dir: &str,
) -> String {
    let vendor_rel = relative_dir_path(target_dir, vendor_dir);
    let base_rel = relative_dir_path(target_dir, project_dir);

    let mut file = format!(
        "<?php\n\n// autoload_static.php @generated by Composer\n\nnamespace Composer\\Autoload;\n\nclass ComposerStaticInit{suffix}\n{{\n"
    );

    let mut initializer_props = Vec::new();

    if !psr4.is_empty() {
        let mut prefix_lengths: BTreeMap<char, BTreeMap<&str, usize>> = BTreeMap::new();
        for m in psr4 {
            if let Some(first_char) = m.namespace.chars().next() {
                prefix_lengths
                    .entry(first_char)
                    .or_default()
                    .insert(&m.namespace, m.namespace.len());
            }
        }

        file.push_str("    public static $prefixLengthsPsr4 = array (\n");
        for (ch, namespaces) in &prefix_lengths {
            let _ = writeln!(file, "        {} => ", php_var_export(&ch.to_string()));
            file.push_str("        array (\n");
            for (ns, len) in namespaces {
                let _ = writeln!(file, "            {} => {},", php_var_export(ns), len);
            }
            file.push_str("        ),\n");
        }
        file.push_str("    );\n\n");
        initializer_props.push("prefixLengthsPsr4");
    }

    if !psr4.is_empty() {
        let mut ns_paths: BTreeMap<&str, Vec<&str>> = BTreeMap::new();
        for m in psr4 {
            ns_paths.entry(&m.namespace).or_default().push(&m.path);
        }

        file.push_str("    public static $prefixDirsPsr4 = array (\n");
        for (ns, paths) in &ns_paths {
            let _ = writeln!(file, "        {} => ", php_var_export(ns));
            file.push_str("        array (\n");
            for (i, path) in paths.iter().enumerate() {
                let code = static_path_code(path, vendor_dir, project_dir, &vendor_rel, &base_rel);
                let _ = writeln!(file, "            {i} => {code},");
            }
            file.push_str("        ),\n");
        }
        file.push_str("    );\n\n");
        initializer_props.push("prefixDirsPsr4");
    }

    if !psr0.is_empty() {
        let mut by_char: BTreeMap<char, BTreeMap<&str, Vec<&str>>> = BTreeMap::new();
        for m in psr0 {
            let first_char = m.namespace.chars().next().unwrap_or('_');
            by_char
                .entry(first_char)
                .or_default()
                .entry(&m.namespace)
                .or_default()
                .push(&m.path);
        }

        file.push_str("    public static $prefixesPsr0 = array (\n");
        for (ch, namespaces) in &by_char {
            let _ = writeln!(file, "        {} => ", php_var_export(&ch.to_string()));
            file.push_str("        array (\n");
            for (ns, paths) in namespaces {
                let _ = write!(file, "            {} => ", php_var_export(ns));
                file.push_str("array (\n");
                for (i, path) in paths.iter().enumerate() {
                    let code =
                        static_path_code(path, vendor_dir, project_dir, &vendor_rel, &base_rel);
                    let _ = writeln!(file, "                {i} => {code},");
                }
                file.push_str("            ),\n");
            }
            file.push_str("        ),\n");
        }
        file.push_str("    );\n\n");
        initializer_props.push("prefixesPsr0");
    }

    if !classmap.is_empty() {
        file.push_str("    public static $classMap = array (\n");
        for (class, abs_path) in classmap {
            let code = static_path_code(abs_path, vendor_dir, project_dir, &vendor_rel, &base_rel);
            let _ = writeln!(file, "        {} => {},", php_var_export(class), code);
        }
        file.push_str("    );\n\n");
        initializer_props.push("classMap");
    }

    if !file_autoloads.is_empty() {
        file.push_str("    public static $files = array (\n");
        for f in file_autoloads {
            let code = static_path_code(&f.path, vendor_dir, project_dir, &vendor_rel, &base_rel);
            let _ = writeln!(
                file,
                "        {} => {},",
                php_var_export(&f.identifier),
                code
            );
        }
        file.push_str("    );\n\n");
        // $files is NOT added to initializer â€” Composer accesses it separately
    }

    file.push_str("    public static function getInitializer(ClassLoader $loader)\n");
    file.push_str("    {\n");
    file.push_str("        return \\Closure::bind(function () use ($loader) {\n");
    for prop in &initializer_props {
        let _ = writeln!(
            file,
            "            $loader->{prop} = ComposerStaticInit{suffix}::${prop};"
        );
    }
    file.push_str("\n        }, null, ClassLoader::class);\n");
    file.push_str("    }\n");
    file.push_str("}\n");

    file
}

pub(crate) fn generate_autoload_php(suffix: &str) -> String {
    format!(
        r#"<?php

// autoload.php @generated by Composer

if (PHP_VERSION_ID < 80000) {{
    if (!headers_sent()) {{
        header('HTTP/1.1 500 Internal Server Error');
    }}
    $err = 'Composer 2.3.0 dropped support for autoloading on PHP <8.0 and you are running ' . PHP_VERSION . ', please upgrade PHP or use Composer 2.2 LTS via "composer self-update --2.2". Aborting.' . PHP_EOL;
    if (!ini_get('display_errors')) {{
        if (PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg') {{
            fwrite(STDERR, $err);
        }} elseif (!headers_sent()) {{
            echo $err;
        }}
    }}
    trigger_error(
        $err,
        E_USER_ERROR
    );
}}

require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInit{suffix}::getLoader();
"#
    )
}

pub(crate) fn generate_autoload_real_php(
    suffix: &str,
    has_platform_check: bool,
    has_files_autoload: bool,
) -> String {
    let platform_check_block = if has_platform_check {
        "\n        require __DIR__ . '/platform_check.php';\n"
    } else {
        ""
    };

    let files_block = if has_files_autoload {
        format!(
            r#"
        $filesToLoad = \Composer\Autoload\ComposerStaticInit{suffix}::$files;
        $requireFile = \Closure::bind(static function ($fileIdentifier, $file) {{
            if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {{
                $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;

                require $file;
            }}
        }}, null, null);
        foreach ($filesToLoad as $fileIdentifier => $file) {{
            $requireFile($fileIdentifier, $file);
        }}
"#
        )
    } else {
        String::new()
    };

    format!(
        r#"<?php

// autoload_real.php @generated by Composer

class ComposerAutoloaderInit{suffix}
{{
    private static $loader;

    public static function loadClassLoader($class)
    {{
        if ('Composer\Autoload\ClassLoader' === $class) {{
            require __DIR__ . '/ClassLoader.php';
        }}
    }}

    /**
     * @return \Composer\Autoload\ClassLoader
     */
    public static function getLoader()
    {{
        if (null !== self::$loader) {{
            return self::$loader;
        }}
{platform_check_block}
        spl_autoload_register(array('ComposerAutoloaderInit{suffix}', 'loadClassLoader'), true, true);
        self::$loader = $loader = new \Composer\Autoload\ClassLoader(\dirname(__DIR__));
        spl_autoload_unregister(array('ComposerAutoloaderInit{suffix}', 'loadClassLoader'));

        require __DIR__ . '/autoload_static.php';
        call_user_func(\Composer\Autoload\ComposerStaticInit{suffix}::getInitializer($loader));

        $loader->register(true);
{files_block}
        return $loader;
    }}
}}
"#
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_static_file_content() {
        let mut classmap = BTreeMap::new();
        classmap.insert(
            "App\\Models\\User".to_string(),
            "/project/src/Models/User.php".to_string(),
        );

        let psr4 = vec![NamespaceMapping {
            namespace: "App\\".to_string(),
            path: "/project/src".to_string(),
        }];

        let content = generate_static_file(
            "abc123",
            &psr4,
            &[],
            &classmap,
            &[],
            "/project/vendor",
            "/project",
            "/project/vendor/composer",
        );

        assert!(content.contains("ComposerStaticInitabc123"));
        assert!(content.contains("$prefixLengthsPsr4"));
        assert!(content.contains("$prefixDirsPsr4"));
        assert!(content.contains("$classMap"));
        assert!(content.contains("App\\\\Models\\\\User"));
        assert!(content.contains("getInitializer"));
    }

    #[test]
    fn relative_dir_path_standard_layout() {
        assert_eq!(
            relative_dir_path("/project/vendor/composer", "/project/vendor"),
            "/.."
        );
        assert_eq!(
            relative_dir_path("/project/vendor/composer", "/project"),
            "/../.."
        );
    }

    #[test]
    fn generate_autoload_php_content() {
        let content = generate_autoload_php("abc123def");
        assert!(content.contains("ComposerAutoloaderInitabc123def::getLoader()"));
        assert!(content.contains("autoload_real.php"));
        assert!(content.contains("PHP_VERSION_ID < 80000"));
    }

    #[test]
    fn generate_autoload_real_with_platform_check_and_files() {
        let content = generate_autoload_real_php("abc123def", true, true);
        assert!(content.contains("class ComposerAutoloaderInitabc123def"));
        assert!(content.contains("platform_check.php"));
        assert!(content.contains("ComposerStaticInitabc123def::$files"));
        assert!(content.contains("autoload_static.php"));
        assert!(content.contains("getInitializer"));
    }

    #[test]
    fn generate_autoload_real_without_platform_check_or_files() {
        let content = generate_autoload_real_php("xyz789", false, false);
        assert!(content.contains("class ComposerAutoloaderInitxyz789"));
        assert!(!content.contains("platform_check.php"));
        assert!(!content.contains("ComposerStaticInitxyz789::$files"));
        assert!(content.contains("autoload_static.php"));
    }
}
